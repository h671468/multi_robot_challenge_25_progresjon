#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math
from sensor_msgs.msg import LaserScan

class NavigationCalculator:
    """
    Navigation Calculations - EN ansvar: Kun navigasjonsberegninger
    
    Single Responsibility: Kun matematiske beregninger for navigasjon
    """
    
    # Constants
    FORWARD_SPEED = 0.3
    TURN_SPEED = 0.5
    THRESHOLD = 0.8
    P_GAIN = 1.0
    
    @staticmethod
    def calculate_goal_commands(dx: float, dy: float, distance_to_goal: float, 
                              dL: float, dR: float, dF: float, 
                              robot_orientation: float) -> tuple:
        """Beregn lineær og vinkelhastighet for Go-to-Goal"""
        linear_x = 0.0
        angular_z = 0.0
        
        # Obstacle avoidance har høyest prioritet
        if dF < NavigationCalculator.THRESHOLD:
            # Obstacle foran - sving til side med minst hinder
            if dL > dR:
                angular_z = NavigationCalculator.TURN_SPEED  # Sving venstre
            else:
                angular_z = -NavigationCalculator.TURN_SPEED  # Sving høyre
            linear_x = 0.1  # Sakte fremover
        else:
            # Ingen hinder foran - naviger mot mål
            desired_heading = math.atan2(dy, dx)
            heading_error = desired_heading - robot_orientation
            
            # Normaliser vinkel til [-π, π]
            heading_error = NavigationCalculator.normalize_angle(heading_error)
            
            # P-kontroll for heading
            angular_z = NavigationCalculator.P_GAIN * heading_error
            
            # Adaptiv lineær hastighet basert på avstand til mål
            linear_x = NavigationCalculator.calculate_adaptive_speed(distance_to_goal)
        
        return linear_x, angular_z

    @staticmethod
    def calculate_wall_following_commands(dL: float, dR: float, dF: float, 
                                        is_turning: bool, turn_time_elapsed: float) -> tuple:
        """Beregn kommandoer for wall following"""
        linear_x = 0.0
        angular_z = 0.0

        if is_turning:
            # Fortsett å svinge i 2.0 sekunder
            if turn_time_elapsed < 2.0:
                linear_x = 0.0
                angular_z = NavigationCalculator.TURN_SPEED
            else:
                linear_x = NavigationCalculator.FORWARD_SPEED
                angular_z = 0.0
        else:
            # Enkel kollisjonsunngåelse og wall following
            if dF < NavigationCalculator.THRESHOLD:
                linear_x = 0.0
                angular_z = NavigationCalculator.TURN_SPEED
            elif dL > NavigationCalculator.THRESHOLD and dR > NavigationCalculator.THRESHOLD:
                linear_x = NavigationCalculator.FORWARD_SPEED
                angular_z = 0.0
            elif dL <= NavigationCalculator.THRESHOLD and dR > NavigationCalculator.THRESHOLD:
                linear_x = NavigationCalculator.FORWARD_SPEED * 0.5
                angular_z = -0.3
            elif dR <= NavigationCalculator.THRESHOLD and dL > NavigationCalculator.THRESHOLD:
                linear_x = NavigationCalculator.FORWARD_SPEED * 0.5
                angular_z = 0.3
            else:
                linear_x = 0.0
                angular_z = NavigationCalculator.TURN_SPEED

        return linear_x, angular_z

    @staticmethod
    def calculate_adaptive_speed(distance_to_goal: float) -> float:
        """Beregn adaptiv hastighet basert på avstand til mål"""
        if distance_to_goal > 2.0:
            return NavigationCalculator.FORWARD_SPEED
        elif distance_to_goal > 1.0:
            return NavigationCalculator.FORWARD_SPEED * 0.7
        else:
            return NavigationCalculator.FORWARD_SPEED * 0.4

    @staticmethod
    def normalize_angle(angle: float) -> float:
        """Normaliser vinkel til [-π, π]"""
        while angle > math.pi:
            angle -= 2 * math.pi
        while angle < -math.pi:
            angle += 2 * math.pi
        return angle

    @staticmethod
    def range_at_deg(scan: LaserScan, deg: float, default: float = 100.0) -> float:
        """Hent avstand ved vinkel (grader) fra LIDAR"""
        if scan is None or not scan.ranges:
            return default
        
        rad = math.radians(deg)
        idx = int(round((rad - scan.angle_min) / scan.angle_increment))
        
        if idx < 0 or idx >= len(scan.ranges):
            return default
        
        d = scan.ranges[idx]
        if d is None or math.isnan(d) or math.isinf(d) or d == 0.0:
            return default
            
        return float(d)

    @staticmethod
    def calculate_distance_to_goal(robot_pos: tuple, goal_pos: tuple) -> float:
        """Beregn avstand til mål"""
        return math.sqrt(
            (goal_pos[0] - robot_pos[0])**2 +
            (goal_pos[1] - robot_pos[1])**2
        )
